import 'dotenv/config';
import express from 'express';
import cors from 'cors';
import open from 'open';
import screenshot from 'screenshot-desktop';
import Tesseract from 'tesseract.js';
import fs from 'fs';
import { connectDB } from './config/database.js';
import ScrapeData from './models/ScrapeData.js';

const app = express();
const PORT = process.env.PORT || 4000;
const SCREENSHOT_WAIT_TIME = parseInt(process.env.SCREENSHOT_WAIT_TIME) || 5000;
const OCR_LANGUAGES = process.env.OCR_LANGUAGES || 'eng+tha';

// Middleware
app.use(cors());
app.use(express.json());

// Default KKDay URL
const defaultUrl = 'https://www.kkday.com/api/_nuxt/product/fetch-packages-data?prodMid=158964&previewToken&beginDate=2025-10-10&endDate=2026-01-05';

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÉ‡∏´‡∏°‡πà‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô /api/scrape-fulljson ‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÉ‡∏ô‡∏ï‡∏±‡∏ß
async function scrapeFullJson(url) {
  if (!url) {
    throw new Error('URL is required');
  }

  try {
    console.log("üåê Opening URL:", url);
    await open(url);

    // ‡∏£‡∏≠‡πÉ‡∏´‡πâ‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏ß‡πá‡∏ö‡πÇ‡∏´‡∏•‡∏î
    await new Promise(resolve => setTimeout(resolve, SCREENSHOT_WAIT_TIME));

    const filename = 'price_screenshot.png';
    await screenshot({ filename });

    console.log("üîç Running OCR...");
    const result = await Tesseract.recognize(filename, OCR_LANGUAGES);
    const text = result.data.text;

    console.log("‚úÖ Full OCR text preview:", text.substring(0, 300) + "...");

    // üîπ Regex: ‡∏´‡∏≤‡πÄ‡∏•‡∏Ç‡∏´‡∏•‡∏±‡∏á B, @ ‡∏´‡∏£‡∏∑‡∏≠ $ (‡∏£‡∏ß‡∏°‡∏ñ‡∏∂‡∏á‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Ñ‡∏≠‡∏°‡∏°‡πà‡∏≤)
    const regex = /(?:\nB|\n@|\n\$|\n$)([\d,]+(?:\.\d+)?)/g;
    const matches = [...text.matchAll(regex)];

    // ‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡∏à‡∏£‡∏¥‡∏á‡πÇ‡∏î‡∏¢‡πÄ‡∏≠‡∏≤‡∏Ñ‡∏≠‡∏°‡∏°‡πà‡∏≤‡∏≠‡∏≠‡∏Å‡πÅ‡∏•‡∏∞‡πÅ‡∏õ‡∏•‡∏á‡∏Ñ‡πà‡∏≤‡πÉ‡∏´‡πâ‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á
    const pricesAraay = matches
      .map(m => parseFloat(m[1].replace(/,/g, '')))  // ‡πÄ‡∏≠‡∏≤‡∏Ñ‡∏≠‡∏°‡∏°‡πà‡∏≤‡∏≠‡∏≠‡∏Å‡πÅ‡∏•‡πâ‡∏ß‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç
      .filter(p => !isNaN(p)); // ‡∏Å‡∏£‡∏≠‡∏á‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç

    const prices = pricesAraay.length > 0 ? pricesAraay[0] : null;
      

    console.log("üí∞ Prices found after B, @, or $:", prices);

    return {
      success: true,
      prices: prices,               // ‡πÄ‡∏ä‡πà‡∏ô [1200.0]
      count: pricesAraay.length,
      screenshotPath: filename,
      fullText: text
    };

  } catch (error) {
    console.error("‚ùå Error scraping page:", error);
    throw new Error(error.message);
  }
}


// Function to perform web scraping with OCR for KKDay
async function scrapeWithOCR(url) {
  try {
    console.log('üåê Opening browser for', url);
    await open(url);

    // Wait for page to load and take screenshot (adjust time as needed)
    await new Promise(resolve => setTimeout(resolve, SCREENSHOT_WAIT_TIME));

    const filename = 'kkday.png';
    console.log('üì∏ Capturing screenshot...');
    await screenshot({ filename });

    console.log('üîç Reading text from screenshot...');
    const result = await Tesseract.recognize(filename, OCR_LANGUAGES);
    const text = result.data.text;

    console.log('\n‚úÖ Extracted text:\n', text.substring(0, 500) + '...');

    // üîç ‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏° parse JSON ‡∏à‡∏≤‡∏Å‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏≠‡πà‡∏≤‡∏ô‡πÑ‡∏î‡πâ
    let parsedJson = null;
    let maxPrice = null;
    let minPrice = null;

    try {
      // ‡∏´‡∏≤‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô JSON ‡πÉ‡∏ô‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° (‡∏≠‡∏≤‡∏à‡∏à‡∏∞‡πÑ‡∏°‡πà‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå)
      const jsonMatch = text.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        // ‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏° clean JSON ‡∏ó‡∏µ‡πà‡∏≠‡∏≤‡∏à‡∏°‡∏µ OCR errors
        let jsonText = jsonMatch[0];
        
        // ‡πÅ‡∏ó‡∏ô‡∏ó‡∏µ‡πà single quotes ‡∏î‡πâ‡∏ß‡∏¢ double quotes
        jsonText = jsonText.replace(/'/g, '"');
        
        // ‡∏•‡∏≠‡∏á‡πÅ‡∏õ‡∏•‡∏á JSON
        try {
          parsedJson = JSON.parse(jsonText);
          console.log('‚úÖ JSON parsed successfully');
        } catch (e) {
          console.log('‚ö†Ô∏è JSON parse failed, using regex fallback');
        }
      }
    } catch (e) {
      console.log('‚ö†Ô∏è No valid JSON found in text');
    }

    // ‡πÉ‡∏ä‡πâ regex ‡∏î‡∏∂‡∏á‡∏Ñ‡πà‡∏≤ max_price ‡πÅ‡∏•‡∏∞ min_price
    const maxPriceMatch = text.match(/max_price['"]?\s*:\s*(\d+)/);
    const minPriceMatch = text.match(/min_price['"]?\s*:\s*(\d+)/);
    maxPrice = maxPriceMatch ? maxPriceMatch[1] : null;
    minPrice = minPriceMatch ? minPriceMatch[1] : null;

    console.log('üí∞ Detected prices:');
    if (maxPrice) console.log(`  max_price = ${maxPrice}`);
    if (minPrice) console.log(`  min_price = ${minPrice}`);

    // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°
    const packageData = {
      prodMid: text.match(/prodMid['":\s]*(\d+)/)?.[1] || null,
      prodOid: text.match(/prod_oid['":\s]*(\d+)/)?.[1] || null,
      items: text.match(/items['":\s]*\[([^\]]+)\]/)?.[1] || null,
      availablePackages: text.match(/available_pkg['":\s]*\[([^\]]+)\]/)?.[1] || null
    };

    // ‡∏™‡πà‡∏á‡∏Ñ‡πà‡∏≤‡∏Å‡∏•‡∏±‡∏ö‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏ó‡∏±‡πâ‡∏á JSON ‡∏ó‡∏µ‡πà parse ‡πÑ‡∏î‡πâ‡πÅ‡∏•‡∏∞‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏î‡∏∂‡∏á‡πÑ‡∏î‡πâ
    return { 
      maxPrice, 
      minPrice, 
      extractedText: text, 
      parsedJson,
      packageData,
      screenshotPath: filename, 
      url 
    }; 

  } catch (error) {
    console.error('‚ùå Error during scraping:', error);
    throw error;
  }
}

// POST /api/scrape - Scrape both KKDay and KLook URLs
app.post('/api/scrape', async (req, res) => {
  const { no_product, name_product, price_product, url_kkday, url_klook, detail } = req.body;

  // Check if both URLs are provided
  if (!url_kkday || !url_klook) {
    return res.status(400).json({
      success: false,
      error: 'Both url_kkday and url_klook are required.'
    });
  }

  console.log('üì° API: /api/scrape called with:', req.body);

  try {
    // ‡πÅ‡∏õ‡∏•‡∏á price_product ‡∏à‡∏≤‡∏Å string ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏à‡∏∏‡∏•‡∏†‡∏≤‡∏Ñ‡πÄ‡∏õ‡πá‡∏ô number
    let parsedPrice = price_product;
    if (typeof price_product === 'string') {
      // ‡∏•‡∏ö‡∏à‡∏∏‡∏•‡∏†‡∏≤‡∏Ñ‡πÅ‡∏•‡∏∞‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô number
      parsedPrice = parseFloat(price_product.replace(/,/g, ''));
    }

    // Scrape URL 1 (KKDay)
    const resultKKDay = await scrapeWithOCR(url_kkday);

    // Scrape URL 2 (KLook) using scrapeFullJson
    const resultKLook = await scrapeFullJson(url_klook);

    // Save the scrape data to MongoDB
    const scrapeRecord = new ScrapeData({
      no_product,
      name_product,
      price_product: parsedPrice,
      url_kkday,
      url_klook,
      detail,
      status: 'success',
      extractedText_kkday: resultKKDay.extractedText,
      maxPrice_kkday: resultKKDay.maxPrice,
      minPrice_kkday: resultKKDay.minPrice,
      screenshotPath_kkday: resultKKDay.screenshotPath,
      extractedText_klook: resultKLook.extractedText,
      maxPrice_klook: resultKLook.prices,
      minPrice_klook: resultKLook.prices,
      screenshotPath_klook: resultKLook.screenshotPath
    });

    const savedData = await scrapeRecord.save();
    console.log('üíæ Data saved to MongoDB:', savedData._id);

    // Send the result back to the client
    res.json({
      success: true,
      data: {
        id: savedData._id,
        no_product,
        name_product,
        price_product: parsedPrice,
        url_kkday,
        url_klook,
        detail,
        kkday: {
          maxPrice: resultKKDay.maxPrice,
          minPrice: resultKKDay.minPrice,
          parsedJson: resultKKDay.parsedJson,
          packageData: resultKKDay.packageData,
          screenshotPath: resultKKDay.screenshotPath
        },
        klook: {
          maxPrice: resultKLook.prices,
          minPrice: resultKLook.prices,
          parsedJson: resultKLook.parsedJson,
          packageData: resultKLook.packageData,
          screenshotPath: resultKLook.screenshotPath,
          fullText: resultKLook.fullText
        },
        createdAt: savedData.createdAt
      }
    });
  } catch (error) {
    console.error('‚ùå Error during scraping:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// POST /api/scrape-price - Scrape prices after ‡∏ø symbol
app.post('/api/scrape-price', async (req, res) => {
  const { url } = req.body;

  if (!url) {
    return res.status(400).json({ 
      success: false, 
      error: 'URL is required' 
    });
  }

  console.log('üì° API: /api/scrape-price called with URL:', url);

  try {
    console.log('üåê Opening URL:', url);
    await open(url);

    // ‡∏£‡∏≠‡πÉ‡∏´‡πâ‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏ß‡πá‡∏ö‡πÇ‡∏´‡∏•‡∏î‡πÄ‡∏™‡∏£‡πá‡∏à
    await new Promise(resolve => setTimeout(resolve, SCREENSHOT_WAIT_TIME));

    const filename = 'price_screenshot.png';
    console.log('üì∏ Capturing screenshot...');
    await screenshot({ filename });

    console.log('üîç Reading text from screenshot...');
    const result = await Tesseract.recognize(filename, OCR_LANGUAGES);
    const text = result.data.text;

    console.log('‚úÖ Extracted text preview:', text.substring(0, 300) + '...');

    // üîç ‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏° parse JSON ‡∏à‡∏≤‡∏Å‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°
    let fullJson = null;
    try {
      const jsonMatch = text.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        let jsonText = jsonMatch[0];
        jsonText = jsonText.replace(/'/g, '"');
        try {
          fullJson = JSON.parse(jsonText);
          console.log('‚úÖ Full JSON parsed successfully');
        } catch (e) {
          console.log('‚ö†Ô∏è Full JSON parse failed');
        }
      }
    } catch (e) {
      console.log('‚ö†Ô∏è No JSON found in text');
    }

    // üîç ‡∏î‡∏∂‡∏á‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡∏´‡∏•‡∏±‡∏á‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏´‡∏°‡∏≤‡∏¢ ‡∏ø
    const priceMatches = [...text.matchAll(/‡∏ø\s*([\d,]+(?:\.\d{2})?)/g)];
    let prices = [];
    
    if (priceMatches.length > 0) {
      prices = priceMatches.map(match => {
        const rawPrice = match[1];
        const numericPrice = parseFloat(rawPrice.replace(/,/g, ''));
        return {
          raw: rawPrice,           // ‡πÄ‡∏ä‡πà‡∏ô "10,668"
          numeric: numericPrice    // ‡πÄ‡∏ä‡πà‡∏ô 10668
        };
      });
      console.log('üí∞ Prices found after ‡∏ø:', prices);
    } else {
      console.log('‚ùå No prices found after ‡∏ø');
    }

    // ‡∏î‡∏∂‡∏á‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏à‡∏∏‡∏•‡∏†‡∏≤‡∏Ñ (‡∏ô‡πà‡∏≤‡∏à‡∏∞‡πÄ‡∏õ‡πá‡∏ô‡∏£‡∏≤‡∏Ñ‡∏≤)
    // ‡∏Å‡∏£‡∏≠‡∏á‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏£‡∏≤‡∏Ñ‡∏≤‡∏à‡∏£‡∏¥‡∏á‡πÜ (100-1,000,000)
    const allNumberMatches = [...text.matchAll(/\b([\d,]+(?:\.\d{2})?)\b/g)];
    const numberWithComma = allNumberMatches
      .map(m => m[1])
      .filter(n => {
        if (!n.includes(',')) return false;
        const numeric = parseFloat(n.replace(/,/g, ''));
        // ‡∏Å‡∏£‡∏≠‡∏á‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡∏ó‡∏µ‡πà‡∏ô‡πà‡∏≤‡∏à‡∏∞‡πÄ‡∏õ‡πá‡∏ô‡∏£‡∏≤‡∏Ñ‡∏≤ (100-1,000,000)
        return numeric >= 100 && numeric <= 1000000;
      });
    
    // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏´‡∏•‡∏±‡∏á ‡∏ø ‡πÅ‡∏ï‡πà‡∏°‡∏µ‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏à‡∏∏‡∏•‡∏†‡∏≤‡∏Ñ ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡∏ï‡∏±‡∏ß‡∏ô‡∏±‡πâ‡∏ô‡πÅ‡∏ó‡∏ô
    let minPrice = null;
    let maxPrice = null;
    
    if (prices.length > 0) {
      // ‡πÉ‡∏ä‡πâ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏à‡∏≤‡∏Å ‡∏ø
      minPrice = Math.min(...prices.map(p => p.numeric));
      maxPrice = Math.max(...prices.map(p => p.numeric));
    } else if (numberWithComma.length > 0) {
      // ‡πÉ‡∏ä‡πâ‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏à‡∏∏‡∏•‡∏†‡∏≤‡∏Ñ
      const numericValues = numberWithComma.map(n => parseFloat(n.replace(/,/g, '')));
      minPrice = Math.min(...numericValues);
      maxPrice = Math.max(...numericValues);
      console.log(`üí∞ Using numbers with comma as prices: min=${minPrice}, max=${maxPrice}`);
      console.log(`   Found numbers: ${numberWithComma.join(', ')}`);
    }

    res.json({
      success: true,
      data: {
        url,
        prices,                    // ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ó‡∏µ‡πà‡∏û‡∏ö‡∏´‡∏•‡∏±‡∏á ‡∏ø
        priceCount: prices.length,
        minPrice,
        maxPrice,
        numberWithComma,           // ‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏à‡∏∏‡∏•‡∏†‡∏≤‡∏Ñ (‡∏ô‡πà‡∏≤‡∏à‡∏∞‡πÄ‡∏õ‡πá‡∏ô‡∏£‡∏≤‡∏Ñ‡∏≤)
        fullJson,                  // JSON ‡∏ó‡∏µ‡πà parse ‡πÑ‡∏î‡πâ
        screenshotPath: filename,
        extractedTextPreview: text.substring(0, 500)
      }
    });

  } catch (error) {
    console.error('‚ùå Error during price scraping:', error);
    res.status(500).json({ 
      success: false, 
      error: error.message 
    });
  }
});

// GET /api/scrape - ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
app.get('/api/scrape', async (req, res) => {
  try {
    const data = await ScrapeData.find().sort({ createdAt: -1 });
    res.json({ success: true, data });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// GET /api/scrape/:id - ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏≤‡∏° id
app.get('/api/scrape/:id', async (req, res) => {
  try {
    const data = await ScrapeData.findById(req.params.id);
    if (!data) return res.status(404).json({ success: false, error: 'Data not found' });
    res.json({ success: true, data });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

app.get('/', async (req, res) => {
  res.send('Hello api');
});


// Connect to MongoDB and start the server
async function startServer() {
  try {
    // Connect to MongoDB
    await connectDB();

    // Start Express server
    app.listen(PORT, () => {
      console.log(`üöÄ Server is running on port ${PORT}`);
      console.log(`üì± API available at: http://localhost:${PORT}`);
      console.log(`üîó Try: http://localhost:${PORT}/api/scrape`);
      console.log(`üìä MongoDB connected: web-scraper database`);
    });
  } catch (error) {
    console.error('‚ùå Failed to start server:', error);
    process.exit(1);
  }
}

// Start the server
startServer();
